generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ProjectStatus {
  active
  archived
}

enum ProjectType {
  SDK
  App
}


enum IncidentStatus {
  open
  investigating
  resolved
  closed
}

enum IncidentSeverity {
  low
  medium
  high
  critical
}

enum LogFileStatus {
  queued
  parsed
  failed
}

// Analysis status for log file analysis
enum AnalysisStatus {
  pending
  analyzing
  completed
  failed
}


// Bluetooth session status
enum SessionStatus {
  scanning
  pairing
  connecting
  connected
  communicating
  disconnected
  timeout
  error
}

// Anomaly pattern types for auto-detection
enum AnomalyType {
  frequent_disconnect
  timeout_retry
  error_burst
  slow_connection
  command_failure
}

model User {
  id           String          @id @default(uuid()) @db.Uuid
  email        String          @unique
  name         String
  passwordHash String
  status       String
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  memberships        ProjectMember[]
  auditActions       AuditLog[]       @relation("AuditActor")
  createdKnownIssues KnownIssue[]     @relation("KnownIssueCreator")
  createdReports     AnalysisReport[] @relation("ReportCreator")
  createdRegressionBaselines LogRegressionBaseline[] @relation("RegressionBaselineCreator")
  createdAssertionRules LogAssertionRule[] @relation("AssertionRuleCreator")
  createdAssertionRuns LogAssertionRun[] @relation("AssertionRunCreator")
}

model Role {
  id      String          @id @default(uuid()) @db.Uuid
  name    String          @unique
  members ProjectMember[]
}

model Project {
  id         String            @id @default(uuid()) @db.Uuid
  name       String
  type       ProjectType
  status     ProjectStatus
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt

  members         ProjectMember[]
  logFiles        LogFile[]
  logEvents       LogEvent[]
  logEventStats   LogEventStats[]
  incidents       Incident[]
  auditLogs       AuditLog[]
  deviceSessions  DeviceSession[]
  anomalyPatterns AnomalyPattern[]
  knownIssues     KnownIssue[]
  analysisReports AnalysisReport[]
  logFileAnalyses LogFileAnalysis[]
  regressionBaselines LogRegressionBaseline[]
  assertionRules LogAssertionRule[]
  assertionRuns LogAssertionRun[]
}

model ProjectMember {
  id        String   @id @default(uuid()) @db.Uuid
  projectId String   @db.Uuid
  userId    String   @db.Uuid
  roleId    String   @db.Uuid
  createdAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id])
  user    User    @relation(fields: [userId], references: [id])
  role    Role    @relation(fields: [roleId], references: [id])

  @@unique([projectId, userId])
  @@index([userId])
  @@index([projectId])
}

model LogFile {
  id          String       @id @default(uuid()) @db.Uuid
  projectId   String       @db.Uuid
  fileName    String
  fileSize    BigInt
  status      LogFileStatus
  storageKey  String
  sourceDevice String?
  parserVersion String?
  uploadedAt  DateTime

  project Project @relation(fields: [projectId], references: [id])
  events  LogEvent[]
  stats   LogEventStats[]
  analysis LogFileAnalysis?
  regressionBaselines LogRegressionBaseline[]
  assertionRuns LogAssertionRun[]

  @@index([projectId, uploadedAt])
}

model LogEvent {
  id          String   @id @default(uuid()) @db.Uuid
  projectId   String   @db.Uuid
  logFileId   String   @db.Uuid
  timestampMs BigInt
  level       Int
  eventName   String
  sdkVersion  String?
  appId       String?
  terminalInfo String?
  threadName  String?
  threadId    BigInt?
  isMainThread Boolean?
  msgJson     Json?
  rawLine     String?
  createdAt   DateTime @default(now())

  // Tracking fields extracted from msgJson
  linkCode    String?   // APP session identifier for tracing device connection flow
  requestId   String?   // Request ID for tracing command send-response chain
  attemptId   String?   // Connection attempt identifier (per connect attempt)
  deviceMac   String?   // Device MAC address for filtering device-specific events
  deviceSn    String?   // Device SN / serial number for filtering device-specific events
  errorCode   String?   // Error code for quick error filtering
  stage       String?   // stage for flow analysis, e.g. ble/http/mqtt
  op          String?   // operation for stage, e.g. scan/connect/publish
  result      String?   // result for op, e.g. start/ok/fail/timeout

  project Project @relation(fields: [projectId], references: [id])
  logFile LogFile @relation(fields: [logFileId], references: [id])
  incidentLinks IncidentLogLink[]

  @@index([projectId, timestampMs])
  @@index([eventName, timestampMs])
  @@index([appId, timestampMs])
  @@index([sdkVersion, eventName])
  @@index([logFileId])
  @@index([linkCode, timestampMs])
  @@index([requestId, timestampMs])
  @@index([projectId, attemptId])
  @@index([deviceMac, timestampMs])
  @@index([deviceSn, timestampMs])
  @@index([errorCode])
  @@index([logFileId, stage])
}

model Incident {
  id        String          @id @default(uuid()) @db.Uuid
  projectId String          @db.Uuid
  title     String
  severity  IncidentSeverity
  status    IncidentStatus
  startTime DateTime
  endTime   DateTime?
  deletedAt DateTime?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  project Project @relation(fields: [projectId], references: [id])
  links   IncidentLogLink[]

  @@index([projectId, status])
}

model IncidentLogLink {
  id         String   @id @default(uuid()) @db.Uuid
  incidentId String   @db.Uuid
  logEventId String   @db.Uuid

  incident Incident @relation(fields: [incidentId], references: [id])
  logEvent LogEvent @relation(fields: [logEventId], references: [id])

  @@unique([incidentId, logEventId])
  @@index([incidentId])
}

model AuditLog {
  id         String   @id @default(uuid()) @db.Uuid
  projectId  String   @db.Uuid
  actorUserId String? @db.Uuid
  action     String
  targetType String
  targetId   String?
  metadata   Json?
  createdAt  DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id])
  actor   User?   @relation("AuditActor", fields: [actorUserId], references: [id])

  @@index([projectId, createdAt])
}

model LogEventStats {
  id        String   @id @default(uuid()) @db.Uuid
  projectId String   @db.Uuid
  logFileId String   @db.Uuid
  eventName String
  level     Int
  count     Int

  project   Project  @relation(fields: [projectId], references: [id])
  logFile   LogFile  @relation(fields: [logFileId], references: [id])

  @@unique([logFileId, eventName, level])
  @@index([projectId, eventName])
}

// Device session aggregated from log events
model DeviceSession {
  id            String        @id @default(uuid()) @db.Uuid
  projectId     String        @db.Uuid
  linkCode      String        // APP session identifier
  deviceMac     String?       // Device MAC address

  startTimeMs   BigInt        // Session start timestamp
  endTimeMs     BigInt?       // Session end timestamp
  durationMs    Int?          // Session duration in milliseconds

  status        SessionStatus // Current session status
  eventCount    Int           @default(0)
  errorCount    Int           @default(0)
  commandCount  Int           @default(0)

  // Phase timestamps for timeline visualization
  scanStartMs     BigInt?
  pairStartMs     BigInt?
  connectStartMs  BigInt?
  connectedMs     BigInt?
  disconnectMs    BigInt?

  sdkVersion    String?
  appId         String?
  terminalInfo  String?
  createdAt     DateTime      @default(now())

  project       Project       @relation(fields: [projectId], references: [id])

  @@unique([projectId, linkCode])
  @@index([projectId, startTimeMs])
  @@index([deviceMac, startTimeMs])
  @@index([status])
}

// Detected anomaly patterns for debugging assistance
model AnomalyPattern {
  id              String      @id @default(uuid()) @db.Uuid
  projectId       String      @db.Uuid
  patternType     AnomalyType
  deviceMac       String?
  sdkVersion      String?

  startTimeMs     BigInt      // Pattern detection start time
  endTimeMs       BigInt      // Pattern detection end time

  occurrenceCount Int         // Number of occurrences
  avgIntervalMs   Int?        // Average interval between occurrences
  affectedSessions Int        // Number of affected sessions
  sampleEventIds  Json        // Sample event IDs for reference

  severity        Int         @default(1) // 1-5 severity level
  description     String?
  createdAt       DateTime    @default(now())

  project         Project     @relation(fields: [projectId], references: [id])

  @@index([projectId, patternType, createdAt])
  @@index([deviceMac])
  @@index([severity])
}

// Issue category for known issues
enum IssueCategory {
  connection
  data
  device
  app
  permission
  protocol
  other
}

// Known issue library for quick diagnosis
model KnownIssue {
  id           String        @id @default(uuid()) @db.Uuid
  projectId    String        @db.Uuid
  errorCode    String?       // Associated error code
  eventPattern String?       // Event name pattern (regex)
  msgPattern   String?       // Message content pattern (regex)

  title        String
  description  String
  solution     String        // Solution/fix steps
  category     IssueCategory @default(other)
  severity     Int           @default(2) // 1-5

  hitCount     Int           @default(0) // Number of matches
  isActive     Boolean       @default(true)

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  createdBy    String?       @db.Uuid

  project      Project       @relation(fields: [projectId], references: [id])
  creator      User?         @relation("KnownIssueCreator", fields: [createdBy], references: [id])

  @@index([projectId, errorCode])
  @@index([projectId, category])
  @@index([isActive])
}

// Report type for analysis reports
enum ReportType {
  session_analysis
  device_comparison
  incident_summary
  error_distribution
  performance_analysis
}

// Assertion rule type for log self-test validation
enum AssertionRuleType {
  event_must_exist
  event_must_not_exist
  event_must_exist_after_anchor
}

// Execution status for assertion validation run
enum AssertionRunStatus {
  pending
  running
  completed
  failed
}

// Analysis report for one-click generation
model AnalysisReport {
  id           String      @id @default(uuid()) @db.Uuid
  projectId    String      @db.Uuid
  title        String
  reportType   ReportType

  content      Json        // Structured report content
  sourceData   Json        // Source data (linkCode, time range, etc.)
  summary      String?     // Text summary

  createdAt    DateTime    @default(now())
  createdBy    String?     @db.Uuid

  project      Project     @relation(fields: [projectId], references: [id])
  creator      User?       @relation("ReportCreator", fields: [createdBy], references: [id])

  @@index([projectId, createdAt])
  @@index([reportType])
}

// Automated log file analysis results
model LogFileAnalysis {
  id              String         @id @default(uuid()) @db.Uuid
  logFileId       String         @unique @db.Uuid
  projectId       String         @db.Uuid

  // Analysis results
  qualityScore    Int            // 0-100 overall quality score
  bleQuality      Json?          // BLE quality report
  backendQuality  Json?          // Backend quality report (HTTP, MQTT)
  anomalies       Json           @default("[]") // Detected anomaly patterns array
  knownIssueMatches Json         @default("[]") // Matched known issues array

  // Quick metrics for dashboard
  totalEvents     Int            @default(0)
  errorEvents     Int            @default(0)
  warningEvents   Int            @default(0)
  sessionCount    Int            @default(0)
  deviceCount     Int            @default(0)

  // Event flow analysis
  mainFlowAnalysis     Json?     // Main flow analysis result (startup to real-time data)
  eventCoverageAnalysis Json?    // Event coverage statistics for all known events

  // Analysis status
  status          AnalysisStatus @default(pending)
  errorMessage    String?        // Error message if analysis failed
  analyzedAt      DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  logFile         LogFile        @relation(fields: [logFileId], references: [id], onDelete: Cascade)
  project         Project        @relation(fields: [projectId], references: [id])

  @@index([projectId, createdAt])
  @@index([status])
  @@index([qualityScore])
}

// Regression baseline snapshot for quality gate
model LogRegressionBaseline {
  id           String   @id @default(uuid()) @db.Uuid
  projectId    String   @db.Uuid
  logFileId    String   @db.Uuid
  name         String
  description  String?
  isActive     Boolean  @default(true)
  snapshot     Json
  thresholds   Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdBy    String?  @db.Uuid

  project      Project  @relation(fields: [projectId], references: [id])
  logFile      LogFile  @relation(fields: [logFileId], references: [id], onDelete: Cascade)
  creator      User?    @relation("RegressionBaselineCreator", fields: [createdBy], references: [id])

  @@index([projectId, createdAt])
  @@index([projectId, isActive])
  @@index([logFileId])
}

// Assertion rules for automated log validation
model LogAssertionRule {
  id           String            @id @default(uuid()) @db.Uuid
  projectId    String            @db.Uuid
  name         String
  description  String?
  ruleType     AssertionRuleType
  definition   Json
  enabled      Boolean           @default(true)
  priority     Int               @default(100)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  createdBy    String?           @db.Uuid

  project      Project           @relation(fields: [projectId], references: [id])
  creator      User?             @relation("AssertionRuleCreator", fields: [createdBy], references: [id])

  @@index([projectId, enabled])
  @@index([projectId, priority])
  @@index([projectId, createdAt])
}

// Assertion run result for a specific log file
model LogAssertionRun {
  id           String             @id @default(uuid()) @db.Uuid
  projectId    String             @db.Uuid
  logFileId    String             @db.Uuid
  status       AssertionRunStatus @default(pending)
  triggeredBy  String             @default("manual")
  totalRules   Int                @default(0)
  passedRules  Int                @default(0)
  failedRules  Int                @default(0)
  passRate     Float              @default(0)
  summary      Json               @default("{}")
  details      Json               @default("[]")
  errorMessage String?
  startedAt    DateTime?
  completedAt  DateTime?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  createdBy    String?            @db.Uuid

  project      Project            @relation(fields: [projectId], references: [id])
  logFile      LogFile            @relation(fields: [logFileId], references: [id], onDelete: Cascade)
  creator      User?              @relation("AssertionRunCreator", fields: [createdBy], references: [id])

  @@index([projectId, createdAt])
  @@index([projectId, status])
  @@index([logFileId])
}
